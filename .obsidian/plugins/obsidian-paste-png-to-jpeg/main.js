/* THIS IS A GENERATED/BUNDLED FILE BY ESBUILD */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "obsidian-paste-png-to-jpeg",
      version: "1.2.2",
      main: "main.js",
      scripts: {
        dev: "node esbuild.config.mjs",
        build: "tsc -noEmit -skipLibCheck && BUILD_ENV=production node esbuild.config.mjs && cp manifest.json build",
        version: "node version-bump.mjs && git add manifest.json versions.json",
        release: "yarn build && gh release create ${npm_package_version} build/*"
      },
      keywords: [],
      author: "Reorx",
      license: "MIT",
      devDependencies: {
        "@types/node": "^16.11.6",
        "@typescript-eslint/eslint-plugin": "^5.2.0",
        "@typescript-eslint/parser": "^5.2.0",
        "builtin-modules": "^3.2.0",
        esbuild: "0.13.12",
        obsidian: "^0.13.26",
        tslib: "2.3.1",
        typescript: "4.4.4"
      },
      dependencies: {
        "cash-dom": "^8.1.1"
      }
    };
  }
});

// src/main.ts
__export(exports, {
  default: () => PastePngToJpegPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// src/utils.ts
var import_path = __toModule(require("path"));
var DEBUG = !(undefined === "production");
function debugLog(...args) {
  if (DEBUG) {
    console.log(new Date().toISOString().slice(11, 23), ...args);
  }
}
var path = {
  join(...partSegments) {
    let parts = [];
    for (let i = 0, l = partSegments.length; i < l; i++) {
      parts = parts.concat(partSegments[i].split("/"));
    }
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
      const part = parts[i];
      if (!part || part === ".")
        continue;
      else
        newParts.push(part);
    }
    if (parts[0] === "")
      newParts.unshift("");
    return newParts.join("/");
  },
  basename(fullpath) {
    const sp = fullpath.split("/");
    return sp[sp.length - 1];
  },
  filename(fullpath) {
    let filename = (0, import_path.basename)(fullpath);
    return filename.substring(0, filename.indexOf("."));
  },
  extension(fullpath) {
    const positions = [...fullpath.matchAll(new RegExp("\\.", "gi"))].map((a) => a.index);
    return fullpath.slice(positions[positions.length - 1] + 1);
  }
};
function ConvertImage(file, quality) {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onloadend = function(e) {
      let image = new Image();
      image.onload = function() {
        let canvas = document.createElement("canvas");
        let context = canvas.getContext("2d");
        let imageWidth = image.width;
        let imageHeight = image.height;
        let data = "";
        canvas.width = imageWidth;
        canvas.height = imageHeight;
        context.fillStyle = "#fff";
        context.fillRect(0, 0, imageWidth, imageHeight);
        context.save();
        context.translate(imageWidth / 2, imageHeight / 2);
        context.drawImage(image, 0, 0, imageWidth, imageHeight, -imageWidth / 2, -imageHeight / 2, imageWidth, imageHeight);
        context.restore();
        data = canvas.toDataURL("image/jpeg", quality);
        var arrayBuffer = base64ToArrayBuffer(data);
        resolve(arrayBuffer);
      };
      image.src = e.target.result.toString();
    };
    reader.readAsDataURL(file);
  });
}
function base64ToArrayBuffer(code) {
  const parts = code.split(";base64,");
  const contentType = parts[0].split(":")[1];
  const fileExt = contentType.split("/")[1];
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);
  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }
  return uInt8Array.buffer;
}

// src/main.ts
var DEFAULT_SETTINGS = {
  imageNamePattern: "{{fileName}}",
  dupNumberAtStart: false,
  dupNumberDelimiter: "-",
  autoRename: true,
  autoMove: true,
  pngToJpeg: true,
  quality: "0.6",
  dirpath: "image/"
};
var PastePngToJpegPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      const pkg = require_package();
      console.log(`Plugin loading: ${pkg.name} ${pkg.version}`);
      yield this.loadSettings();
      this.registerEvent(this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian.TFile))
          return;
        const timeGapMs = Date.now() - file.stat.ctime;
        if (timeGapMs > 1e3)
          return;
        if (isImage(file)) {
          debugLog("pasted image created", file);
          this.renameFile(file);
        }
      }));
      this.addSettingTab(new SettingTab(this.app, this));
    });
  }
  renameFile(file) {
    return __async(this, null, function* () {
      const activeFile = this.getActiveFile();
      if (!activeFile) {
        new import_obsidian.Notice("Error: No active file found.");
        return;
      }
      let newName = yield this.keepOrgName(file, activeFile);
      if (this.settings.autoRename) {
        newName = yield this.generateNewName(file, activeFile);
      }
      const sourcePath = activeFile.path;
      let newPath = "";
      if (this.settings.autoMove) {
        const imagePath = this.app.vault.getConfig("attachmentFolderPath") + "/" + this.settings.dirpath;
        const isCreate = yield this.app.vault.adapter.exists(imagePath);
        if (!isCreate) {
          yield this.app.vault.createFolder(imagePath);
        }
        newPath = imagePath;
      } else {
        newPath = file.parent.path + +"/" + this.settings.dirpath;
      }
      const originName = file.name;
      if (this.settings.pngToJpeg) {
        let binary = yield this.app.vault.readBinary(file);
        let imgBlob = new Blob([binary]);
        let arrayBuffer = yield ConvertImage(imgBlob, Number(this.settings.quality));
        yield this.app.vault.modifyBinary(file, arrayBuffer);
      }
      const linkText = this.makeLinkText(file, sourcePath);
      newPath = path.join(newPath, newName);
      try {
        yield this.app.vault.rename(file, newPath);
      } catch (err) {
        new import_obsidian.Notice(`Failed to rename ${newName}: ${err}`);
        throw err;
      }
      const newLinkText = this.makeLinkText(file, sourcePath);
      debugLog("replace text", linkText, newLinkText);
      const editor = this.getActiveEditor(sourcePath);
      if (!editor) {
        new import_obsidian.Notice(`Failed to rename ${newName}: no active editor`);
        return;
      }
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      debugLog("current line", line);
      editor.transaction({
        changes: [
          {
            from: __spreadProps(__spreadValues({}, cursor), { ch: 0 }),
            to: __spreadProps(__spreadValues({}, cursor), { ch: line.length }),
            text: line.replace(linkText, newLinkText)
          }
        ]
      });
      new import_obsidian.Notice(`Renamed ${originName} to ${newName}`);
    });
  }
  makeLinkText(file, sourcePath, subpath) {
    return this.app.fileManager.generateMarkdownLink(file, sourcePath, subpath);
  }
  generateNewName(file, activeFile) {
    return __async(this, null, function* () {
      const newName = activeFile.basename + "-" + Date.now();
      const extension = this.settings.pngToJpeg ? "jpeg" : file.extension;
      return `${newName}.${extension}`;
    });
  }
  keepOrgName(file, activeFile) {
    return __async(this, null, function* () {
      const newName = file.basename;
      const extension = this.settings.pngToJpeg ? "jpeg" : file.extension;
      return `${newName}.${extension}`;
    });
  }
  getActiveFile() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const file = view == null ? void 0 : view.file;
    debugLog("active file", file == null ? void 0 : file.path);
    return file;
  }
  getActiveEditor(sourcePath) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      if (view.file.path == sourcePath) {
        return view.editor;
      }
    }
    return null;
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var IMAGE_EXTS = [
  "jpg",
  "jpeg",
  "png"
];
function isImage(file) {
  if (file instanceof import_obsidian.TFile) {
    if (IMAGE_EXTS.contains(file.extension.toLowerCase())) {
      return true;
    }
  }
  return false;
}
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Png to Jpeg").setDesc(`Paste images from ClipBoard to notes by copying them through various screenshot software,turn on this feature will automatically convert png to jpeg, and more quality compression volume.`).addToggle((toggle) => toggle.setValue(this.plugin.settings.pngToJpeg).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pngToJpeg = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Quality").setDesc(`The smaller the Quality, the greater the compression ratio.`).addDropdown((toggle) => toggle.addOptions({ "0.1": "0.1", "0.2": "0.2", "0.3": "0.3", "0.4": "0.4", "0.5": "0.5", "0.6": "0.6", "0.7": "0.7", "0.8": "0.8", "0.9": "0.9", "1.0": "1.0" }).setValue(this.plugin.settings.quality).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.quality = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Auto Rename").setDesc(`Automatically names the image with the name of the previous note +'-'+ the current timestamp + '.' + file type, for example, the image in test.md will be named test-1652261724173.jpeg`).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRename).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoRename = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Auto Move Image").setDesc(`Automatically move images to the image directory,If you do not set the default directory for attachments, then it will be stored directly under the image/ folder in the same directory as the notes, if there is a default directory, then it will be stored under the image/ folder in the Magician directory`).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoMove).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoMove = value;
      yield this.plugin.saveSettings();
    })));
  }
};


/* nosourcemap */