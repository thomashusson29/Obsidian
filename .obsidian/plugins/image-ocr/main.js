/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TesseractOcrPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var DEFAULT_SETTINGS = {
  imagePath: "Meta/Attachments",
  tesseractLanguage: "eng",
  tesseractPath: "",
  debug: false
};
var TesseractOcrPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "run",
      name: "Run",
      callback: async () => {
        let startNotice = new import_obsidian.Notice("Searching for image links...");
        const statusBarItemEl = this.addStatusBarItem();
        statusBarItemEl.setText("Inserting details...");
        let insertionCounter = 0;
        let checkedFilesCounter = 0;
        let allImages = [];
        import_obsidian.Vault.recurseChildren(app.vault.getRoot(), (file) => {
          if (file.path.contains(this.settings.imagePath) && this.isImage(file)) {
            allImages.push(file);
          }
        });
        console.log(allImages.length + " Images found!");
        let files = this.getAllFiles();
        for (const file of files) {
          if (this.isMarkdown(file.name)) {
            checkedFilesCounter++;
            let linkRegex = /!\[\[.*\]\](?!<details>)/g;
            let content = await this.app.vault.cachedRead(file);
            let newContent = content;
            let matches = this.getImageMatches(newContent.match(linkRegex), allImages);
            if (matches.length !== 0)
              console.log("found " + matches.length + " images without details in file " + file.name + " processing...");
            let errorCounter = 0;
            for (let i = 0; i < matches.length; i++) {
              if (this.settings.debug == true)
                console.log("details dont exist on file: " + file.name + " link: " + matches[i].match);
              let index = newContent.indexOf(matches[i].match) + matches[i].match.length;
              try {
                let text = await this.getTextFromImage(matches[i].path);
                text = this.formatTesseractOutput(text);
                let detailsToAdd = "<details>" + text + "</details>\n";
                newContent = newContent.slice(0, index) + detailsToAdd + newContent.slice(index);
              } catch (e) {
                console.error(e);
                errorCounter++;
                let detailsToAdd = "<details></details>\n";
                newContent = newContent.slice(0, index) + detailsToAdd + newContent.slice(index);
              }
              insertionCounter++;
            }
            if (content !== newContent) {
              if (this.settings.debug == true)
                console.log("writing to note!");
              this.app.vault.adapter.write(file.path, newContent);
            }
            if (errorCounter > 0)
              console.log(errorCounter + " errors encountered in this file: " + file.name);
          }
        }
        ;
        statusBarItemEl.remove();
        startNotice.hide();
        let finishNotice = new import_obsidian.Notice(`Done. Checked ${checkedFilesCounter} files and inserted ${insertionCounter} image descriptions.`);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getAllFiles() {
    let files = this.app.vault.getAllLoadedFiles();
    let onlyFiles = [];
    for (const f of files) {
      if (f instanceof import_obsidian.TFile) {
        onlyFiles.push(f);
      }
    }
    return onlyFiles;
  }
  getImageMatches(list, allImages) {
    if (list === null) {
      return [];
    }
    let newList = [];
    for (let j = 0; j < list.length; j++) {
      for (let i = 0; i < allImages.length; i++) {
        if (list[j].contains(allImages[i].name)) {
          newList.push({ match: list[j], path: allImages[i].path });
        }
      }
    }
    ;
    return newList;
  }
  isImage(file) {
    return file instanceof import_obsidian.TFile && ["jpg", "png", "jpeg"].includes(file.extension);
  }
  isMarkdown(fileName) {
    if (["md"].includes(fileName.split(".")[fileName.split(".").length - 1])) {
      return true;
    } else {
      return false;
    }
  }
  async getTextFromImage(filePath) {
    let fullPath = this.app.vault.adapter.getFullPath(filePath);
    let command = this.settings.tesseractPath + "tesseract";
    let commandArgs = [fullPath, "-", "-l", this.settings.tesseractLanguage];
    if (this.settings.debug == true)
      console.log("command to be run: " + command + " " + commandArgs.join(" "));
    return new Promise((resolve, reject) => {
      let execution = (0, import_child_process.spawn)(command, commandArgs);
      const error = [];
      const stdout = [];
      execution.stderr.on("data", (data) => {
        error.push(data.toString());
      });
      execution.stdout.on("data", (data) => {
        stdout.push(data.toString());
      });
      execution.on("error", (e) => {
        error.push(e.toString());
      });
      execution.on("close", () => {
        if (this.settings.debug == true)
          console.log("tesseract output: " + stdout.join(""));
        if (this.settings.debug == true)
          console.log("tesseract output: " + error.join(""));
        if (stdout.join("").length == 0)
          reject(error.join(""));
        else
          resolve(stdout.join(""));
      });
    });
  }
  formatTesseractOutput(text) {
    let returnString = "";
    let lines = text.split("\n");
    lines.forEach((element) => {
      element = element.trim();
      for (let i = 0; i < 10; i++) {
        element = element.replace(i + ". ", i + ".");
        element = element.replace(i + ") ", i + ")");
      }
      const ltReg = new RegExp("<", "g");
      element = element.replace(ltReg, "&lt;");
      const gtReg = new RegExp(">", "g");
      element = element.replace(gtReg, "&gt;");
      const starReg = new RegExp("\\* ", "g");
      element = element.replace(starReg, "");
      const hyphenReg = new RegExp("- ", "g");
      element = element.replace(hyphenReg, "");
      if (element != "") {
        returnString += element + "\n";
      }
    });
    return returnString;
  }
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for image-ocr!" });
    new import_obsidian.Setting(containerEl).setName("Image Path").setDesc('Path to were all the images are stored (I recommend using the "Local Images Plus" plugin.').addText((text) => text.setPlaceholder("Enter relative path").setValue(this.plugin.settings.imagePath).onChange(async (value) => {
      this.plugin.settings.imagePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tesseract Path").setDesc("Tesseract executable path. Leave empty if tesseract is in the environment PATH variable.").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.tesseractPath).onChange(async (value) => {
      this.plugin.settings.tesseractPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tesseract Language").setDesc("Language codes that improve tesseracts ocr. Make sure you have the language pack installed.").addText((text) => text.setPlaceholder("eng").setValue(this.plugin.settings.tesseractLanguage).onChange(async (value) => {
      this.plugin.settings.tesseractLanguage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug").setDesc("Shows debug output in console.").addToggle((text) => text.setValue(this.plugin.settings.debug).onChange(async (value) => {
      this.plugin.settings.debug = value;
      await this.plugin.saveSettings();
    }));
  }
};

/* nosourcemap */